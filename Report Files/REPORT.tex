\documentclass[12pt, a4paper]{article}

% --- ΒΑΣΙΚΑ ΠΑΚΕΤΑ ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % <-- Πρόσθεσε αυτή τη γραμμή
\usepackage[greek]{babel}
\usepackage{geometry} % Για τα περιθώρια
\geometry{a4paper, margin=1in} % Περιθώρια 1 ίντσα
\usepackage{graphicx} % Για εισαγωγή εικόνων
\usepackage{hyperref} % Για υπερσυνδέσμους (π.χ. στον πίνακα περιεχομένων)
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Αναφορά Project HW-1},
    pdfpagemode=FullScreen,
}

% --- ΠΑΚΕΤΑ ΓΙΑ ΚΩΔΙΚΑ ---
\usepackage{listings} % Για εισαγωγή κώδικα

\usepackage{xcolor} % Για χρώματα στον κώδικα

% --- Ρυθμίσεις για το 'listings' (Verilog) ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{verilogstyle}{
    language=Verilog,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize, % Μέγεθος γραμματοσειράς κώδικα
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    % Αρίθμηση γραμμών
    numbersep=5pt,                   
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{
    basicstyle=\ttfamily\selectlanguage{english}\footnotesize,
}


% --- ΣΤΟΙΧΕΙΑ ΕΡΓΑΣΙΑΣ ---
\title{Ψηφιακά Συστήματα \textlatin{HW} σε Χαμηλά Επίπεδα Λογικής I \\ \textlatin{Project's Report}}
\author{Νίκος Τουλκερίδης\\ ΑΕΜ: 10718}
\date{Νοέμβριος 2025}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                   ΚΥΡΙΩΣ ΑΝΑΦΟΡΑ                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle % Δημιουργία σελίδας τίτλου

\newpage
\tableofcontents % Πίνακας περιεχομένων

\newpage
\section*{Εισαγωγή}\addcontentsline{toc}{section}{Εισαγωγή}

Η παρούσα εργασία υλοποιήθηκε στα πλαίσια του μαθήματος <<Ψηφιακά Συστήματα \textlatin{HW} σε Χαμηλά Επίπεδα Λογικής I>>.
Κεντρικός στόχος είναι η σχεδίαση, η υλοποίηση σε γλώσσα περιγραφής υλικού \textlatin{Verilog} και η προσομοίωση της λειτουργίας τεσσάρων διακριτών ψηφιακών κυκλωμάτων, τα οποία συνδυάζονται για να δημιουργήσουν ένα ολοκληρωμένο, αν και απλό, σύστημα.
Η εργασία αποτελείται από τέσσερα βασικά μέρη:

\begin{itemize}
    \item \textbf{Άσκηση 1:} Σχεδίαση μιας 32-\textlatin{bit} Αριθμητικής/Λογικής Μονάδας (\textlatin{ALU}), ικανής να εκτελεί 12 διαφορετικές αριθμητικές, λογικές πράξεις και πράξεις ολίσθησης.
    \item \textbf{Άσκηση 2:} Υλοποίηση μιας απλής αριθμομηχανής 16-\textlatin{bit}, η οποία χρησιμοποιεί την \textlatin{ALU} της Άσκησης 1 και έναν συσσωρευτή (\textlatin{accumulator}) για να εκτελεί διαδοχικούς υπολογισμούς.
    \item \textbf{Άσκηση 3:} Σχεδίαση ενός αρχείου καταχωρητών (\textlatin{register file}) μεγέθους 16*32-\textlatin{bit}, το οποίο διαθέτει πολλαπλές θύρες ανάγνωσης (4) και εγγραφής (2).
    \item \textbf{Άσκηση 4:} Σχεδίαση και υλοποίηση ενός μικρού επιταχυντή \textlatin{AI} (\textlatin{AI accelerator}) που μοντελοποιεί ένα απλό νευρωνικό δίκτυο.
Αυτό το τελικό σύστημα χρησιμοποιεί την \textlatin{ALU} (μέσω μιας μονάδας \textlatin{MAC}) και το \textlatin{register file} για την εκτέλεση των απαιτούμενη υπολογισμών.
\end{itemize}

Στις επόμενες ενότητες αυτής της αναφοράς παρουσιάζεται αναλυτικά η σχεδιαστική προσέγγιση που ακολουθήθηκε, ο πλήρης κώδικας \textlatin{Verilog} για κάθε \textlatin{module}, καθώς και τα αποτελέσματα της προσομοίωσης που χρησιμοποιήθηκαν για την επαλήθευση της ορθής λειτουργίας τους.

%% -- 1 -- %%
\newpage
\section{Άσκηση 1: Αριθμητική/Λογική Μονάδα (\textlatin{ALU})}

% 1.1
\subsection{Σκοπός και Προδιαγραφές}
Ο σκοπός της πρώτης άσκησης ήταν η σχεδίαση και υλοποίηση σε \textlatin{Verilog} μιας Αριθμητικής/Λογικής Μονάδας (\textlatin{ALU}) 32-\textlatin{bit}.
Η μονάδα αυτή θα αποτελέσει δομικό στοιχείο για τις επόμενες ασκήσεις, συγκεκριμένα την αριθμομηχανή και τον επιταχυντή \textlatin{AI}.
Βάσει των προδιαγραφών, η \textlatin{ALU} έπρεπε να σχεδιαστεί ως ένα αμιγώς \textbf{συνδυαστικό κύκλωμα} (\textlatin{combinational circuit}).
Αυτό σημαίνει ότι οι έξοδοί της εξαρτώνται αποκλειστικά από τις τρέχουσες τιμές των εισόδων και δεν υπάρχει μνήμη κατάστασης, ούτε ανάγκη για σήμα ρολογιού ή επαναφοράς.
Οι θύρες εισόδου και εξόδου της μονάδας, όπως καθορίστηκαν στον πίνακα της εκφώνησης, είναι:
\begin{itemize}
    \item \textbf{Είσοδοι:} \texttt{\textlatin{op1}} (32-\textlatin{bit}) και \texttt{\textlatin{op2}} (32-\textlatin{bit}) ως οι δύο προσημασμένοι τελεστές σε μορφή συμπληρώματος ως προς 2, και \texttt{\textlatin{alu\_op}} (4-\textlatin{bit}) ως σήμα ελέγχου για την επιλογή της εκτελούμενης πράξης.
    \item \textbf{Έξοδοι:} \texttt{\textlatin{result}} (32-\textlatin{bit}) που φέρει το αποτέλεσμα της πράξης, \texttt{\textlatin{zero}} (1-\textlatin{bit}) που ενεργοποιείται (γίνεται 1) όταν το \texttt{\textlatin{result}} είναι μηδέν, και \texttt{\textlatin{ovf}} (1-\textlatin{bit}) που σηματοδοτεί υπερχείλιση (\textlatin{overflow}) για τις αριθμητικές πράξεις (πρόσθεση, αφαίρεση, πολλαπλασιασμός).
\end{itemize}

Η \textlatin{ALU} σχεδιάστηκε για να υποστηρίζει 12 διαφορετικές πράξεις, οι οποίες επιλέγονται από την είσοδο \texttt{\textlatin{alu\_op}} και ομαδοποιούνται ως εξής:
\begin{itemize}
    \item \textbf{Αριθμητικές (Προσημασμένες):} Πρόσθεση (\textlatin{4'b0100}), Αφαίρεση (\textlatin{4'b0101}), Πολλαπλασιασμός (\textlatin{4'b0110}).
    \item \textbf{Λογικές:} \textlatin{AND} (\textlatin{4'b1000}), \textlatin{OR} (\textlatin{4'b1001}), \textlatin{NOR} (\textlatin{4'b1010}), \textlatin{NAND} (\textlatin{4'b1011}), \textlatin{XOR} (\textlatin{4'b1100}).
    \item \textbf{Ολισθήσεις:} Λογική Δεξιά/Αριστερά (\textlatin{4'b0000}, \textlatin{4'b0001}) και Αριθμητική Δεξιά/Αριστερά (\textlatin{4'b0010}, \textlatin{4'b0011}).
\end{itemize}
Όπως απαιτήθηκε, οι 4-\textlatin{bit} κωδικοί για αυτές τις πράξεις ορίστηκαν ως σταθερές \texttt{\textlatin{parameter}} εντός του \textlatin{module} \texttt{\textlatin{alu.v}} για βελτιωμένη αναγνωσιμότητα.

% 1.2
\subsection{Υλοποίηση (\textlatin{alu.v})}
Η υλοποίηση της \textlatin{ALU} (αρχείο \texttt{\textlatin{alu.v}}) βασίστηκε σε ένα κεντρικό συνδυαστικό μπλοκ \texttt{\textlatin{always @(*)}}.
Εντός αυτού του μπλοκ, ένας \textbf{πολυπλέκτης} υλοποιήθηκε χρησιμοποιώντας μια δομή \texttt{\textlatin{case}}.
Αυτή η δομή ελέγχει την είσοδο \texttt{\textlatin{alu\_op}} και επιλέγει την κατάλληλη λογική για τον υπολογισμό του \texttt{\textlatin{result}} και του \texttt{\textlatin{ovf}}.
Οι είσοδοι \texttt{\textlatin{op1}} και \texttt{\textlatin{op2}} δηλώθηκαν ως \texttt{\textlatin{signed}}, κάτι που είναι κρίσιμο για να εξασφαλιστεί ότι η \textlatin{Verilog} θα εκτελέσει τις αριθμητικές πράξεις και την αριθμητική ολίσθηση δεξιά ως προσημασμένες.
Ιδιαίτερη προσοχή δόθηκε στον ορθό υπολογισμό της υπερχείλισης (\texttt{\textlatin{ovf}}) για τις τρεις προσημασμένες αριθμητικές πράξεις, χρησιμοποιώντας ενδιάμεσα \textlatin{wires} για σαφήνεια:
\begin{itemize}
    \item \textbf{Πρόσθεση (\textlatin{SUM}):} Η υπερχείλιση ανιχνεύεται όταν οι δύο τελεστές έχουν το ίδιο πρόσημο (\textlatin{bit} 31) και το αποτέλεσμα (\texttt{\textlatin{add\_res}}) έχει διαφορετικό πρόσημο από αυτούς.
    \item \textbf{Αφαίρεση (\textlatin{SUB}):} Η υπερχείλιση ανιχνεύεται όταν οι τελεστές έχουν διαφορετικό πρόσημο και το αποτέλεσμα (\texttt{\textlatin{sub\_res}}) έχει διαφορετικό πρόσημο από τον μειωτέο (\texttt{\textlatin{op1}}).
    \item \textbf{Πολλαπλασιασμός (\textlatin{MUL}):} Ο πολλαπλασιασμός 32*32 παράγει ένα ενδιάμεσο αποτέλεσμα 64-\textlatin{bit} (\texttt{\textlatin{mul\_res}}).
    Υπερχείλιση συμβαίνει εάν το αποτέλεσμα δεν χωράει σε 32 \textlatin{bits}, δηλαδή αν τα 32 ανώτερα \textlatin{bits} (\texttt{\textlatin{mul\_res[63:32]}}) δεν αποτελούν απλή επέκταση προσήμου (\textlatin{sign-extension}) του 31ου \textlatin{bit}.
\end{itemize}
Για όλες τις λογικές πράξεις και τις ολισθήσεις, η σημαία \texttt{\textlatin{ovf}} τίθεται πάντα σε \textlatin{1'b0}, καθώς η υπερχείλιση δεν ορίζεται για αυτές.
Για τις πράξεις ολίσθησης, αξιοποιήθηκε η συμπεριφορά της \textlatin{Verilog}:
\begin{itemize}
    \item \textbf{Αριθμητική Δεξιά Ολίσθηση} (\texttt{\textlatin{> > >}}): Επειδή ο \texttt{\textlatin{op1}} είναι \texttt{\textlatin{signed}}, ο τελεστής αυτός διατηρεί αυτόματα το πρόσημο (γεμίζει με το \textlatin{MSB}).
    \item \textbf{Λογική Δεξιά Ολίσθηση} (\texttt{\textlatin{> >}}): Απαιτήθηκε ρητή μετατροπή (\textlatin{casting}) του τελεστή σε \texttt{\textlatin{\$unsigned(op1)}} για να εξασφαλιστεί ότι η ολίσθηση θα γεμίσει τα κενά με μηδενικά, ανεξαρτήτως προσήμου.
    \item \textbf{Αριστερές Ολισθήσεις} (\texttt{\textlatin{< <}}): Η λογική και η αριθμητική αριστερή ολίσθηση είναι \textbf{ταυτόσημες} και γεμίζουν πάντα με μηδενικά.
\end{itemize}
Τέλος, η σημαία \texttt{\textlatin{zero}} υλοποιήθηκε εκτός του \texttt{\textlatin{always}} μπλοκ, με μια συνεχή ανάθεση (\texttt{\textlatin{assign zero = (result == 32'b0)}}).
Αυτό εξασφαλίζει ότι η έξοδος \texttt{\textlatin{zero}} είναι 1 οποτεδήποτε το τελικό \texttt{\textlatin{result}} είναι μηδέν.
Μια \texttt{\textlatin{default}} περίπτωση προστέθηκε στη δομή \texttt{\textlatin{case}} για την αποφυγή συμπερασμού \textlatin{latches}.
Ο πλήρης κώδικας της μονάδας παρατίθεται στο αρχείο \texttt{\textlatin{alu.v}}.

% 1.3
\subsection{\textlatin{Testbench} και Αποτελέσματα Προσομοίωσης}
Για την επαλήθευση της ορθής λειτουργίας της \textlatin{ALU}, δημιουργήθηκε ένα \textlatin{testbench} στο αρχείο \texttt{\textlatin{testbench\_alu.v}}.
Το \textlatin{testbench} αυτό εκτελεί μια σειρά από προκαθορισμένες δοκιμές μέσω ενός \texttt{\textlatin{initial block}}.
Χρησιμοποιήθηκε ένα βοηθητικό \texttt{\textlatin{task}} με όνομα \texttt{\textlatin{check\_op}}, το οποίο αναλαμβάνει να θέσει τις τιμές των εισόδων \texttt{\textlatin{tb\_op1}}, \texttt{\textlatin{tb\_op2}} και \texttt{\textlatin{tb\_alu\_op}}, να αναμένει 10\textlatin{ns} για τη διάδοση του αποτελέσματος στο συνδυαστικό κύκλωμα, και κατόπιν να εκτυπώσει στην κονσόλα την εκτελούμενη πράξη, τις εισόδους, το αποτέλεσμα (\texttt{\textlatin{tb\_result}}) και τις σημαίες (\texttt{\textlatin{tb\_ovf}}, \texttt{\textlatin{tb\_zero}}) σε δεκαεξαδική μορφή.
Οι δοκιμές κάλυψαν και τις 12 πράξεις, δίνοντας έμφαση σε οριακές περιπτώσεις:
\begin{itemize}
    \item Έλεγχος θετικής (\textlatin{MAX\_INT + 1}) και αρνητικής υπερχείλισης για την πρόσθεση (\textlatin{SUM}).
    \item Έλεγχος της σημαίας \texttt{\textlatin{zero}} με την αφαίρεση \texttt{25 - 25}.
    \item Έλεγχος υπερχείλισης για την αφαίρεση (\textlatin{MIN\_INT - 1}).
    \item Έλεγχος υπερχείλισης για τον πολλαπλασιασμό (\texttt{2\textsuperscript{16} * 2\textsuperscript{16}}).
    \item Σύγκριση μεταξύ λογικής και αριθμητικής δεξιάς ολίσθησης σε έναν αρνητικό αριθμό (\textlatin{32'hF000000A}), για να επιβεβαιωθεί η σωστή διατήρηση (ή μη) του προσήμου.
\end{itemize}
Η εκτέλεση του \textlatin{testbench} (όπως φαίνεται στην έξοδο της κονσόλας) επιβεβαίωσε ότι όλες οι πράξεις, συμπεριλαμβανομένων των οριακών συνθηκών, παράγουν τα αναμενόμενα αποτελέσματα και ότι οι σημαίες \texttt{\textlatin{ovf}} και \texttt{\textlatin{zero}} ενεργοποιούνται σωστά.
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{alu_tb_out.png}
    \caption{Έξοδος κονσόλας από την εκτέλεση του \texttt{\textlatin{testbench\_alu.v}}, που δείχνει την επιτυχή επαλήθευση των οριακών συνθηκών.}
    \label{fig:alu_tb_out}
\end{figure}

% 1.4
\subsection{Συμπέρασμα Άσκησης 1}
Η σχεδίαση της 32-\textlatin{bit} \textlatin{ALU} ολοκληρώθηκε με επιτυχία.
Η μονάδα που υλοποιήθηκε στο \texttt{\textlatin{alu.v}} είναι ένα αμιγώς συνδυαστικό κύκλωμα που εκτελεί σωστά και τις 12 απαιτούμενες αριθμητικές, λογικές και πράξεις ολίσθησης.
Οι μηχανισμοί ανίχνευσης υπερχείλισης και μηδενικού αποτελέσματος λειτουργούν όπως αναμένεται, σύμφωνα με την επαλήθευση που έγινε με το \textlatin{testbench}.
Αυτή η \textlatin{ALU} είναι πλέον έτοιμη να ενσωματωθεί στα πιο σύνθετα συστήματα των επόμενων ασκήσεων.



%% -- 2 -- %%
\newpage
\section{Άσκηση 2: Αριθμομηχανή \textlatin{16-bit}}

% 2.1
\subsection{Σκοπός και Προδιαγραφές}
Σκοπός της δεύτερης άσκησης ήταν η σχεδίαση μιας απλής αριθμομηχανής, η οποία χρησιμοποιεί την \textlatin{32-bit} \textlatin{ALU} που δημιουργήθηκε στην Άσκηση 1. Το κύκλωμα της αριθμομηχανής (\textlatin{module} \texttt{\textlatin{calc}}) σχεδιάστηκε για να διατηρεί μια τρέχουσα τιμή σε έναν καταχωρητή συσσωρευτή (\textlatin{accumulator}) \textlatin{16-bit}.

Οι είσοδοι του κυκλώματος είναι το σήμα ρολογιού (\texttt{\textlatin{clk}}), πέντε πλήκτρα ελέγχου (\texttt{\textlatin{btnc}}, \texttt{\textlatin{btnac}}, \texttt{\textlatin{btnl}}, \texttt{\textlatin{btnr}}, \texttt{\textlatin{btnd}}) και 16 διακόπτες (\texttt{\textlatin{sw}}) για την εισαγωγή δεδομένων. Η μοναδική έξοδος είναι 16 \textlatin{LED} (\texttt{\textlatin{led}}), τα οποία απεικονίζουν την τρέχουσα τιμή του συσσωρευτή.

% 2.2
\subsection{Σχεδίαση και Ροή Δεδομένων}
Η υλοποίηση (αρχείο \texttt{\textlatin{calc.v}}) βασίστηκε στο διάγραμμα ροής (Σχ. 1 της εκφώνησης). Το σύστημα αποτελείται από δύο βασικά μέρη: το ακολουθιακό κύκλωμα του συσσωρευτή και το συνδυαστικό κύκλωμα της \textlatin{ALU} και της λογικής ελέγχου.

\paragraph{Ακολουθιακή Λογική (\textlatin{Accumulator})}
Η καρδιά του συστήματος είναι ο \textlatin{16-bit} καταχωρητής \texttt{\textlatin{accumulator}}, ο οποίος υλοποιήθηκε με ένα μπλοκ \texttt{\textlatin{always @(posedge clk)}}. Η λειτουργία του είναι σύγχρονη, όπως απαιτήθηκε:
\begin{itemize}
    \item \textbf{Σύγχρονος Μηδενισμός:} Όταν το πλήκτρο \texttt{\textlatin{btnac}} (\textlatin{All Clear}) είναι πατημένο, ο \texttt{\textlatin{accumulator}} μηδενίζεται στην επόμενη θετική ακμή του ρολογιού.
    \item \textbf{Σύγχρονη Φόρτωση:} Όταν το κεντρικό πλήκτρο \texttt{\textlatin{btnc}} είναι πατημένο (και το \texttt{\textlatin{btnac}} δεν είναι), ο \texttt{\textlatin{accumulator}} λαμβάνει και αποθηκεύει τα 16 κατώτερα \textlatin{bits} (\texttt{\textlatin{[15:0]}}) του αποτελέσματος της \textlatin{ALU} (\texttt{\textlatin{alu\_result\_wire}}).
\end{itemize}
Η τιμή του \texttt{\textlatin{accumulator}} οδηγείται συνεχώς στην έξοδο \texttt{\textlatin{led}} μέσω μιας \texttt{\textlatin{assign}} δήλωσης.

\paragraph{Συνδυαστική Λογική (Ροή \textlatin{ALU})}
Η \textlatin{ALU} της Άσκησης 1 είναι \textlatin{32-bit}, ενώ η αριθμομηχανή λειτουργεί με τιμές \textlatin{16-bit}. Για να γεφυρωθεί αυτό το χάσμα, χρησιμοποιήθηκε επέκταση προσήμου (\textlatin{sign extension}) και για τις δύο εισόδους της \textlatin{ALU}:
\begin{itemize}
    \item \textbf{Είσοδος \textlatin{op1}:} Η \textlatin{16-bit} τιμή του \texttt{\textlatin{accumulator}} μετατρέπεται σε \textlatin{32-bit} προσημασμένη τιμή (\texttt{\textlatin{op1\_signed}}) επαναλαμβάνοντας το ανώτερο \textlatin{bit} του (\texttt{\textlatin{accumulator[15]}}) 16 φορές. Αυτό υλοποιήθηκε με τον τελεστή \textlatin{concatenation}: \texttt{\{\{16\{\textlatin{accumulator}[15]\}\}, \textlatin{accumulator}\}}.
    \item \textbf{Είσοδος \textlatin{op2}:} Αντίστοιχα, η \textlatin{16-bit} είσοδος από τους διακόπτες (\texttt{\textlatin{sw}}) επεκτείνεται σε \textlatin{32-bit} προσημασμένη τιμή (\texttt{\textlatin{op2\_signed}}) για να οδηγηθεί στην \texttt{\textlatin{op2}} είσοδο της \textlatin{ALU}.
\end{itemize}
Το \textlatin{32-bit} αποτέλεσμα (\texttt{\textlatin{result}}) της \textlatin{ALU} (\texttt{\textlatin{alu\_result\_wire}}) τροφοδοτείται πίσω στην είσοδο του \texttt{\textlatin{accumulator}}, ο οποίος (όπως αναφέρθηκε) κρατά μόνο τα 16 κατώτερα \textlatin{bits}.

% 2.3
\subsection{Λογική Ελέγχου (\texttt{\textlatin{calc\_enc.v}})}
Η επιλογή της πράξης που εκτελεί η \textlatin{ALU} δεν γίνεται απευθείας. Αντ' αυτού, ένα ξεχωριστό \textlatin{module} κωδικοποιητή, το \texttt{\textlatin{calc\_enc.v}}, αναλαμβάνει να μετατρέψει τις τιμές των τριών πλήκτρων κατεύθυνσης (\texttt{\textlatin{btnl}}, \texttt{\textlatin{btnr}}, \texttt{\textlatin{btnd}}) στο \textlatin{4-bit} σήμα ελέγχου \texttt{\textlatin{alu\_op}}.

Όπως απαιτήθηκε από τις προδιαγραφές (Σχήματα 2-5), αυτό το \textlatin{module} υλοποιήθηκε αμιγώς σε \textbf{\textlatin{structural Verilog}}. Η λογική περιγράφηκε χρησιμοποιώντας αποκλειστικά στιγμιότυπα πυλών (\textlatin{gate instances}) όπως \texttt{\textlatin{not}}, \texttt{\textlatin{and}}, \texttt{\textlatin{or}} και \texttt{\textlatin{xor}}, αντί για \textlatin{behavioral} αναθέσεις. Αυτή η μονάδα στη συνέχεια ενσωματώθηκε (\textlatin{instantiated}) στο \textlatin{top-level module} \texttt{\textlatin{calc.v}} και η έξοδός της (\texttt{\textlatin{alu\_op\_wire}}) συνδέθηκε απευθείας στην ομώνυμη είσοδο της \textlatin{ALU}.

% 2.4
\subsection{\textlatin{Testbench} και Αποτελέσματα Προσομοίωσης}
Για την επαλήθευση της ορθής λειτουργίας της αριθμομηχανής, δημιουργήθηκε το αρχείο \texttt{\textlatin{calc\_tb.v}}. Το \textlatin{testbench} αυτό υλοποιεί την ακριβή ακολουθία δοκιμών που ορίζεται στον πίνακα των προδιαγραφών (Πίνακες σελ. 7 και 8).

Το \textlatin{testbench} παράγει ένα σήμα ρολογιού (\texttt{\textlatin{CLK\_PERIOD = 10ns}}) και χρησιμοποιεί ένα βοηθητικό \texttt{\textlatin{task}} με όνομα \texttt{\textlatin{check\_step}}. Αυτό το \texttt{\textlatin{task}} είναι κρίσιμο για τον έλεγχο του ακολουθιακού κυκλώματος: σε κάθε βήμα, θέτει τις τιμές των εισόδων (πλήκτρα και διακόπτες), αναμένει την επόμενη θετική ακμή του ρολογιού (\texttt{\textlatin{@ (posedge clk)}}) και, τέλος, ελέγχει αν η έξοδος \texttt{\textlatin{led}} ταιριάζει με την αναμενόμενη τιμή (\texttt{\textlatin{expected\_led}}).

Η ακολουθία ελέγχου ξεκινά με \texttt{\textlatin{RESET}} (\texttt{\textlatin{btnac=1}}) και εκτελεί τις 8 πράξεις \textlatin{(ADD, XOR, LSR, NOR, MULT, LSL, NAND, SUB)} με τη σειρά, θέτοντας το \texttt{\textlatin{btnc=1}} σε κάθε βήμα για να φορτώσει το αποτέλεσμα στον \texttt{\textlatin{accumulator}}.

Η εκτέλεση του \textlatin{testbench} ήταν απόλυτα επιτυχής. Παρακάτω, το Σχήμα 2 δείχνει την έξοδο της κονσόλας, όπου επιβεβαιώνεται ότι και τα 9 βήματα της δοκιμής (συμπεριλαμβανομένου του \textlatin{RESET}) πέρασαν, με την τιμή των \textlatin{LED} να είναι η αναμενόμενη σε κάθε κύκλο. Το Σχήμα 3 παρουσιάζει τις αντίστοιχες κυματομορφές προσομοίωσης, όπου φαίνεται η σχέση μεταξύ των πλήκτρων, του \texttt{\textlatin{alu\_op\_wire}}, της εκτέλεσης της \textlatin{ALU} και της σύγχρονης ενημέρωσης του \texttt{\textlatin{accumulator}} (εξόδου \textlatin{led}) στην ακμή του ρολογιού.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{calc_tb_out.png}
    \caption{Έξοδος κονσόλας από την εκτέλεση του \texttt{\textlatin{calc\_tb.v}}. Κάθε γραμμή \textlatin{PASS} επιβεβαιώνει ότι η τιμή των \textlatin{LED} \textlatin{(accumulator)} ταυτίστηκε με το αναμενόμενο αποτέλεσμα μετά από κάθε πράξη.}
    \label{fig:calc_tb_out}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{epwave_calc.png}
    \caption{Κυματομορφές προσομοίωσης (\textlatin{EPWave}) του \texttt{\textlatin{calc\_tb.v}}. Φαίνεται η αλλαγή του \texttt{\textlatin{alu\_op\_wire}} βάσει των \textlatin{btns}, και η σύγχρονη ενημέρωση του \texttt{\textlatin{led}} \textlatin{(accumulator)} στην επόμενη θετική ακμή του \texttt{\textlatin{clk}} (όταν \texttt{\textlatin{btnc}} είναι 1).}
    \label{fig:epwave_calc}
\end{figure}

\subsection{Συμπέρασμα Άσκησης 2}
Η Άσκηση 2 ολοκληρώθηκε με επιτυχία, ενσωματώνοντας την συνδυαστική \textlatin{ALU} της Άσκησης 1 σε ένα πλήρες ακολουθιακό κύκλωμα. Η σχεδίαση διαχειρίζεται σωστά τη ροή δεδομένων μεταξύ στοιχείων \textlatin{16-bit} (όπως ο \texttt{\textlatin{accumulator}} και το \texttt{\textlatin{sw}}) και της \textlatin{32-bit} \textlatin{ALU} μέσω της επέκτασης προσήμου (\textlatin{sign extension}). Η λογική ελέγχου, υλοποιημένη σε ξεχωριστό \textlatin{structural module} (\texttt{\textlatin{calc\_enc.v}}), καθώς και η σύγχρονη λογική φόρτωσης και μηδενισμού του συσσωρευτή, λειτούργησαν όπως αναμενόταν κατά την επιτυχή προσομοίωση.





%% -- 3 -- %%
\newpage
\section{Άσκηση 3: Αρχείο Καταχωρητών (\textlatin{Register File})}

% 3.1
\subsection{Σκοπός και Προδιαγραφές}
Σκοπός της τρίτης άσκησης ήταν η σχεδίαση ενός αρχείου καταχωρητών (\textlatin{register file})
πολλαπλών θυρών, το οποίο θα αποτελέσει βασικό δομικό στοιχείο αποθήκευσης (π.χ. για
βάρη και πολώσεις) στον επιταχυντή ΑΙ της Άσκησης 4.

Βάσει των προδιαγραφών, το \textlatin{module} \texttt{\textlatin{regfile.v}} έπρεπε να υλοποιήσει ένα αρχείο 16
καταχωρητών, με κάθε καταχωρητή να έχει πλάτος \texttt{\textlatin{DATAWIDTH}}.
Αυτό το πλάτος ορίστηκε
ως \textlatin{parameter} του \textlatin{module}, με προεπιλεγμένη τιμή τα 32 \textlatin{bits}, δημιουργώντας έτσι μια δομή
\textlatin{16x32-bit}.

Το κύκλωμα είναι εξαιρετικά πολυθύρικο (\textlatin{multi-ported}) για να επιτρέπει υψηλό παραλ-
ληλισμό, διαθέτοντας:
\begin{itemize}
    \item \textbf{Εισόδους Ελέγχου:} \texttt{\textlatin{clk}} (ρολόι), \texttt{\textlatin{resetn}} (ενεργό-χαμηλό ασύγχρονο σήμα επα-
ναφοράς) και \texttt{\textlatin{write}} (σήμα ενεργοποίησης εγγραφής).
    \item \textbf{Θύρες Εγγραφής (2):} Δύο πλήρεις, ανεξάρτητες θύρες εγγραφής. Η κάθε μία
αποτελείται από μια \textlatin{4-bit} διεύθυνση (\texttt{\textlatin{writeReg1}}, \texttt{\textlatin{writeReg2}}) και έναν \textlatin{bus} δεδομένων
\textlatin{32-bit} (\texttt{\textlatin{writeData1}}, \texttt{\textlatin{writeData2}}).
    \item \textbf{Θύρες Ανάγνωσης (4):} Τέσσερις ανεξάρτητες θύρες ανάγνωσης. Η κάθε μία α-
ποτελείται από μια \textlatin{4-bit} διεύθυνση (\texttt{\textlatin{readReg1}} έως \texttt{\textlatin{readReg4}}) και έναν \textlatin{bus} δεδομένων
εξόδου \textlatin{32-bit} (\texttt{\textlatin{readData1}} έως \texttt{\textlatin{readData4}}).
\end{itemize}

% 3.2
\subsection{Υλοποίηση και Λογική Λειτουργίας (\textlatin{regfile.v})}
Η υλοποίηση στο αρχείο \texttt{\textlatin{regfile.v}} διαχωρίζει τη λειτουργία του κυκλώματος σε δύο δια-
κριτά λογικά μπλοκ: ένα ακολουθιακό μπλοκ για την εγγραφή (την αποθήκευση) και ένα
συνδυαστικό μπλοκ για την ανάγνωση (την πρόσβαση).

\paragraph{Εσωτερική Αποθήκευση}
Ο πυρήνας του \textlatin{module} είναι ένας πίνακας από \textlatin{registers} 16
θέσεων, δηλωμένος ως: \texttt{\textlatin{logic [DATAWIDTH-1:0] registers [16];}}.
Αυτός ο πίνακας
αποτελεί τη μνήμη του \textlatin{register file}.

\paragraph{Ακολουθιακή Λογική (Εγγραφή και \textlatin{Reset})}
Η κατάσταση των καταχωρητών (η
μνήμη) τροποποιείται αποκλειστικά εντός ενός ακολουθιακού μπλοκ \texttt{\textlatin{always\_ff @(posedge clk or negedge resetn)}}.
\begin{itemize}
    \item \textbf{Ασύγχρονο \textlatin{Reset}:} Όπως ορίστηκε στις προδιαγραφές, το σήμα \texttt{\textlatin{resetn}} είναι
ενεργό-χαμηλό.
Όταν \texttt{\textlatin{resetn == 0}}, το κύκλωμα αντιδρά αμέσως (ασύγχρονα, χωρίς
να περιμένει το ρολόι) και μηδενίζει όλους τους 16 καταχωρητές ταυτόχρονα, χρησι-
μοποιώντας έναν βρόχο \texttt{\textlatin{for}}.
    \item \textbf{Σύγχρονη Εγγραφή:} Εάν το \texttt{\textlatin{resetn}} δεν είναι ενεργό, το κύκλωμα αναμένει τη
θετική ακμή του \texttt{\textlatin{clk}}.
Εάν το σήμα \texttt{\textlatin{write}} είναι ενεργό (\texttt{\textlatin{write == 1}}) κατά την ακμή,
οι τιμές από τα \texttt{\textlatin{writeData1}} και \texttt{\textlatin{writeData2}} αποθηκεύονται στους καταχωρητές στις
θέσεις \texttt{\textlatin{writeReg1}} και \texttt{\textlatin{writeReg2}} αντίστοιχα.
    \item \textbf{Σύγκρουση Εγγραφής (\textlatin{Write Collision}):} Στην περίπτωση που και οι δύο
θύρες εγγραφής στοχεύουν την ίδια διεύθυνση ταυτόχρονα (\texttt{\textlatin{writeReg1 == writeReg2}}),
η σχεδίαση δίνει προτεραιότητα στη δεύτερη θύρα. Λόγω της διαδοχικής ανάθεσης
μέσα στο \texttt{\textlatin{always}} μπλοκ, η τιμή του \texttt{\textlatin{writeData2}} θα είναι αυτή που τελικά θα αποθη-
κευτεί.
\end{itemize}

\paragraph{Συνδυαστική Λογική (Ανάγνωση και \textlatin{Bypass})}
Η ανάγνωση των δεδομένων υ-
λοποιείται σε ένα ξεχωριστό, αμιγώς συνδυαστικό μπλοκ \texttt{\textlatin{always\_comb}}.
Αυτό σημαίνει ότι η
ανάγνωση είναι ασύγχρονη (οι έξοδοι \texttt{\textlatin{readData}} αλλάζουν αμέσως μόλις αλλάξει μια είσοδος
\texttt{\textlatin{readReg}}).

Το σημαντικότερο χαρακτηριστικό αυτού του μπλοκ είναι η υλοποίηση της λογικής πα-
ράκαμψης (\textlatin{bypass}), όπως απαιτήθηκε από τις προδιαγραφές (<<δώστε προτεραιότητα στην
εγγραφή>>).
\begin{enumerate}
    \item \textbf{Προεπιλεγμένη Ανάγνωση:} Αρχικά, οι τέσσερις έξοδοι (\texttt{\textlatin{readData1}}... \texttt{\textlatin{readData4}})
λαμβάνουν τις τιμές που είναι ήδη αποθηκευμένες στον πίνακα \texttt{\textlatin{registers}} στις α-
ντίστοιχες διευθύνσεις ανάγνωσης.
    \item \textbf{Λογική \textlatin{Bypass}:} Στη συνέχεια, το μπλοκ ελέγχει αν το σήμα \texttt{\textlatin{write}} είναι ενεργό.
Αν είναι, το κύκλωμα ελέγχει αν κάποια από τις διευθύνσεις εγγραφής (\texttt{\textlatin{writeReg1}},
\texttt{\textlatin{writeReg2}}) ταιριάζει με κάποια από τις διευθύνσεις ανάγνωσης.
    \item \textbf{Παράδειγμα \textlatin{Bypass}:} Εάν \texttt{\textlatin{write == 1}} και ταυτόχρονα \texttt{\textlatin{writeReg1 == readReg1}},
η έξοδος \texttt{\textlatin{readData1}} δεν θα δείξει την παλιά τιμή από το \texttt{\textlatin{registers[readReg1]}}, αλ-
λά θα πάρει συνδυαστικά την τιμή κατευθείαν από την είσοδο \texttt{\textlatin{writeData1}}.
Αυτό
επιτρέπει σε μια εντολή να διαβάσει το αποτέλεσμα μιας άλλης που γράφεται στον \textbf{ίδιο
κύκλο ρολογιού}, χωρίς να χρειάζεται να περιμένει τον επόμενο.
    \item \textbf{Προτεραιότητα \textlatin{Bypass}:} Η λογική αυτή σέβεται επίσης την προτεραιότητα σύγκρου-
σης.
Οι έλεγχοι για τη \texttt{\textlatin{writeReg2}} γίνονται \textbf{μετά} τους ελέγχους για τη \texttt{\textlatin{writeReg1}}.
Επομένως, αν \texttt{\textlatin{writeReg1 == writeReg2 == readReg1}}, η έξοδος \texttt{\textlatin{readData1}} θα
πάρει την τιμή από το \texttt{\textlatin{writeData2}}, διατηρώντας συνέπεια μεταξύ της λογικής εγ-
γραφής και της λογικής ανάγνωσης.
\end{enumerate}

% 3.3
\subsection{\textlatin{Testbench} και Αποτελέσματα Προσομοίωσης}
Για την επαλήθευση της σύνθετης αυτής λογικής, χρησιμοποιήθηκε το αρχείο \texttt{\textlatin{testbench\_regfile.v}}.
Το \textlatin{testbench} ελέγχει αυστηρά όλα τα κρίσιμα σενάρια λειτουργίας:
\begin{itemize}
    \item \textbf{Ασύγχρονος Μηδενισμός:} Επιβεβαιώθηκε ότι η ενεργοποίηση του \texttt{\textlatin{resetn}} μη-
δενίζει όλους τους καταχωρητές ακαριαία, ανεξαρτήτως ρολογιού.
    \item \textbf{Βασική Εγγραφή/Ανάγνωση:} Ελέγχθηκε η εγγραφή δεδομένων σε πολλαπλές
διευθύνσεις και η σωστή ανάγνωσή τους σε επόμενους κύκλους.
    \item \textbf{Σύγκρουση Εγγραφής (Ακολουθιακά):} Ελέγχθηκε ότι όταν και οι δύο θύρες
γράφουν στην ίδια διεύθυνση, η τιμή από τη \texttt{\textlatin{writeData2}} είναι αυτή που αποθηκεύεται
μόνιμα.
    \item \textbf{Λογική \textlatin{Bypass} (Συνδυαστικά):} Ελέγχθηκε το πιο κρίσιμο σενάριο: ενώ οι
θύρες ανάγνωσης διάβαζαν παλιές τιμές, το σήμα \texttt{\textlatin{write}} ενεργοποιήθηκε.
Το \textlatin{testbench} επιβεβαίωσε ότι οι έξοδοι \texttt{\textlatin{readData}} άλλαξαν \textbf{αμέσως} (συνδυαστικά) για να
δείξουν τις νέες τιμές από τα \texttt{\textlatin{writeData}}, \textbf{πριν} την άφιξη της επόμενης ακμής του
ρολογιού.
    \item \textbf{Σύγκρουση \textlatin{Bypass}:} Επιβεβαιώθηκε ότι η συνδυαστική λογική παράκαμψης δίνει
επίσης προτεραιότητα στη \texttt{\textlatin{writeData2}} σε περίπτωση σύγκρουσης.
    \item \textbf{Μονιμότητα Εγγραφής:} Τέλος, ελέγχθηκε ότι τα δεδομένα που εμφανίστηκαν κατά
το \textlatin{bypass} όντως αποθηκεύτηκαν μόνιμα στους καταχωρητές μετά την ακμή του ρολογιού.
\end{itemize}
Όλες οι παραπάνω δοκιμές ολοκληρώθηκαν με επιτυχία, επαληθεύοντας την ορθή σχεδίαση.
Το σχήμα 4 δείχνει την έξοδο της κονσόλας από την εκτέλεση του \textlatin{testbench},
επιβεβαιώνοντας την επιτυχία όλων των δοκιμών.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{tb_regfile_1-2.png}
    \hfill
    \includegraphics[width=0.49\textwidth]{tb_regfile_3-4.png}
    \caption{Έξοδος κονσόλας του \texttt{\textlatin{testbench\_regfile.v}}. 
    Αριστερά (\textlatin{Tests} 1-2): Έλεγχος ασύγχρονου \textlatin{reset} και βασικής εγγραφής/ανάγνωσης. 
    Δεξιά (\textlatin{Tests} 3-5): Έλεγχος σύγκρουσης, \textlatin{bypass} και τελικής αποθήκευσης.}
    \label{fig:regfile_tb_combined}
\end{figure}

% 3.4
\subsection{Συμπέρασμα Άσκησης 3}
Η σχεδίαση του αρχείου καταχωρητών \textlatin{16x32-bit} ολοκληρώθηκε με επιτυχία. Το \textlatin{module}
\texttt{\textlatin{regfile.v}} υλοποιεί σωστά όλες τις προδιαγραφές, συμπεριλαμβανομένης της παραμετρο-
ποίησης \texttt{\textlatin{DATAWIDTH}}, του ασύγχρονου ενεργού-χαμηλού \textlatin{reset}, και της σύνθετης λογικής
για τις τέσσερις θύρες ανάγνωσης και τις δύο θύρες εγγραφής.
Ιδιαίτερα, η υλοποίηση της
συνδυαστικής λογικής παράκαμψης (\textlatin{bypass}) με καθορισμένη προτεραιότητα (\textlatin{<<write-first>>})
εξασφαλίζει τη σωστή και αποδοτική ροή δεδομένων, καθιστώντας το \textlatin{module} έτοιμο για
ενσωμάτωση στο τελικό σύστημα.


%% -- 4 -- %%
\newpage
\section{Άσκηση 4: Επιταχυντής \textlatin{AI}}

% 4.1
\subsection{Σκοπός και Αρχιτεκτονική Συστήματος}
Η Άσκηση 4 αποτελεί την τελική φάση του \textlatin{project}, όπου όλα τα προηγούμενα \textlatin{modules} ενσωματώνονται για τη δημιουργία ενός ολοκληρωμένου ψηφιακού συστήματος: ενός απλού επιταχυντή \textlatin{AI} (νευρωνικού δικτύου) βασισμένου στο διάγραμμα του Σχήματος 6 των προδιαγραφών.

Το σύστημα αυτό σχεδιάστηκε ως ένας εξειδικευμένος επεξεργαστής \textlatin{datapath} ελεγχόμενος από μια κεντρική Μηχανή Πεπερασμένων Καταστάσεων (\textlatin{Finite State Machine} - \textlatin{FSM}). Η συνολική αρχιτεκτονική (στο αρχείο \texttt{\textlatin{nn.v}}) αποτελείται από:
\begin{itemize}
    \item Μια μνήμη \textlatin{ROM} (\texttt{\textlatin{rom.v}}) που περιέχει τα βάρη (\textlatin{weights}) και τις πολώσεις (\textlatin{biases}) του δικτύου.
    \item Το αρχείο καταχωρητών \textlatin{16x32-bit} (\texttt{\textlatin{regfile.v}} της Άσκησης 3) για την αποθήκευση αυτών των τιμών μετά τη φόρτωση από τη \textlatin{ROM}.
    \item Δύο μονάδες \textlatin{ALU} (\texttt{\textlatin{alu.v}} της Άσκησης 1) για την εκτέλεση των πράξεων ολίσθησης στα στάδια προ- και μετά-επεξεργασίας.
    \item Δύο νέες μονάδες \textlatin{Multiply-Accumulate} (\texttt{\textlatin{mac\_unit.v}}) για την εκτέλεση των υπολογισμών των νευρώνων.
    \item Μια κεντρική μονάδα ελέγχου \textlatin{FSM} και ενδιάμεσους καταχωρητές για τον συντονισμό ολόκληρης της ροής δεδομένων.
\end{itemize}

% 4.2
\subsection{Υλοποίηση Μονάδας \textlatin{MAC} (\texttt{\textlatin{mac\_unit.v}})}
Πριν από την υλοποίηση του τελικού \textlatin{top-level module}, σχεδιάστηκε η βοηθητική μονάδα \texttt{\textlatin{mac\_unit.v}}. Σκοπός της είναι να εκτελεί την σύνθετη πράξη \texttt{(\textlatin{op1} * \textlatin{op2}) + \textlatin{op3}}, που αποτελεί τον πυρήνα υπολογισμού ενός νευρώνα.

Όπως ορίστηκε στις προδιαγραφές, το \textlatin{module} αυτό δεν σχεδιάστηκε ως ένας βελτιστοποιημένος πολλαπλασιαστής-αθροιστής, αλλά ως ένα δομικό (\textlatin{structural}) \textlatin{module} που συνδέει δύο από τις \textlatin{ALU} της Άσκησης 1 σε σειρά.
\begin{itemize}
    \item Η πρώτη \textlatin{ALU} (\texttt{\textlatin{u\_alu\_mul}}) λαμβάνει τα \texttt{\textlatin{op1}} και \texttt{\textlatin{op2}} και εκτελεί \textit{πάντα} την πράξη του πολλαπλασιασμού (\texttt{\textlatin{ALUOP\_MUL}}).
    \item Η δεύτερη \textlatin{ALU} (\texttt{\textlatin{u\_alu\_add}}) λαμβάνει ως \texttt{\textlatin{op1}} το αποτέλεσμα (\texttt{\textlatin{result}}) της πρώτης \textlatin{ALU} και ως \texttt{\textlatin{op2}} την είσοδο \texttt{\textlatin{op3}} (την πόλωση/bias), εκτελώντας \textit{πάντα} την πράξη της πρόσθεσης (\texttt{\textlatin{ALUOP\_SUM}}).
\end{itemize}
Η μονάδα \texttt{\textlatin{mac\_unit.v}} είναι αμιγώς συνδυαστική και εξάγει το τελικό αποτέλεσμα (\texttt{\textlatin{total\_result}}) καθώς και τις σημαίες \texttt{\textlatin{zero}}/\texttt{\textlatin{ovf}} και από τα δύο στάδια (\texttt{\textlatin{zero\_mul}}, \texttt{\textlatin{ovf\_mul}}, \texttt{\textlatin{zero\_add}}, \texttt{\textlatin{ovf\_add}}), όπως απαιτήθηκε.

% 4.3
\subsection{Σχεδίαση Κεντρικής Μονάδας (\texttt{\textlatin{nn.v}})}
Ο πυρήνας του επιταχυντή \textlatin{AI} υλοποιήθηκε στο \textlatin{top-level module} \texttt{\textlatin{nn.v}}. Αυτό περιέχει τη λογική ελέγχου (\textlatin{FSM}) και το \textlatin{datapath} (τις \textlatin{instantiations} των \texttt{\textlatin{alu}}, \texttt{\textlatin{mac\_unit}}, \texttt{\textlatin{regfile}}, \texttt{\textlatin{rom}} και τους ενδιάμεσους καταχωρητές).

\paragraph{Επιλογή Τύπου \textlatin{FSM} (\textlatin{Moore vs Mealy})}
Οι προδιαγραφές επέτρεπαν την επιλογή μεταξύ \textlatin{Mealy} και \textlatin{Moore FSM}. Για αυτήν την υλοποίηση, επιλέχθηκε η σχεδίαση μιας \textbf{\textlatin{FSM} τύπου \textlatin{Moore}}.
\begin{itemize}
    \item \textbf{Αιτιολόγηση:} Σε μια \textlatin{Moore FSM}, οι έξοδοι εξαρτώνται αποκλειστικά από την τρέχουσα κατάσταση (\texttt{\textlatin{current\_state}}) και όχι από τις τρέχουσες (ασύγχρονες) εισόδους. Στη σχεδίασή μας (\texttt{\textlatin{nn.v}}), όλες οι τελικές έξοδοι (\texttt{\textlatin{final\_output}}, \texttt{\textlatin{total\_ovf}}, κ.λπ.) ανατίθενται απευθείας από τους καταχωρητές κατάστασης (π.χ. \texttt{\textlatin{final\_output\_reg}}). Όλα τα σήματα ελέγχου του \textlatin{datapath} (π.χ. \texttt{\textlatin{rf\_write\_enable\_s}}, \texttt{\textlatin{alu1\_op\_s}}) καθορίζονται επίσης μόνο από την \texttt{\textlatin{current\_state}} μέσα στο συνδυαστικό μπλοκ.
    \item \textbf{Υλοποίηση:} Αυτό επιτεύχθηκε με τον κλασικό διαχωρισμό της λογικής σε δύο \textlatin{blocks}:
        \begin{enumerate}
            \item Ένα ακολουθιακό \texttt{\textlatin{always\_ff}} που χειρίζεται το \texttt{\textlatin{resetn}} και την ενημέρωση του \texttt{\textlatin{current\_state}} και όλων των καταχωρητών σε κάθε \texttt{\textlatin{posedge clk}}.
            \item Ένα συνδυαστικό \texttt{\textlatin{always\_comb}} που ορίζει την \texttt{\textlatin{next\_state}} και \textit{όλα} τα σήματα του \textlatin{datapath} βασιζόμενο αποκλειστικά στην \texttt{\textlatin{current\_state}}.
        \end{enumerate}
    \item \textbf{Πλεονεκτήματα:} Αυτή η προσέγγιση απλοποιεί τον συγχρονισμό, καθιστά το \textlatin{timing} πιο προβλέψιμο και αποτρέπει τη δημιουργία ανεπιθύμητων συνδυαστικών βρόχων (\textlatin{combinational loops}).
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{FSM.png}
    \caption{Διάγραμμα των 7 καταστάσεων (\textlatin{states}) της \textlatin{Moore FSM} και των μεταξύ τους μεταβάσεων, όπως υλοποιήθηκαν στο \texttt{\textlatin{nn.v}}.}
\end{figure}

\paragraph{Επιλογή Αποθήκευσης Ενδιάμεσων Τιμών}
Οι προδιαγραφές επέτρεπαν την αποθήκευση ενδιάμεσων αποτελεσμάτων (π.χ. \texttt{\textlatin{inter\_1}}) είτε πίσω στο \texttt{\textlatin{regfile.v}} είτε σε αποκλειστικούς καταχωρητές.
\begin{itemize}
    \item \textbf{Επιλογή:} Επιλέχθηκε η χρήση \textbf{αποκλειστικών ενδιάμεσων καταχωρητών} (π.χ. \texttt{\textlatin{inter\_1\_reg}}, \texttt{\textlatin{inter\_3\_reg}}, \texttt{\textlatin{temp\_result\_reg}}, κ.λπ.).
    \item \textbf{Αιτιολόγηση:} Η επαναχρησιμοποίηση του \texttt{\textlatin{regfile.v}} (στις δεσμευμένες διευθύνσεις \texttt{\textlatin{0x12-0x15}}) θα απαιτούσε πολύπλοκο έλεγχο των θυρών. Για παράδειγμα, στο \texttt{\textlatin{STATE\_INPUT\_LAYER}}, θα χρειαζόταν να διαβάσουμε 4 τιμές (\texttt{\textlatin{weight\_1, bias\_1, weight\_2, bias\_2}}) και ταυτόχρονα να γράψουμε 2 τιμές (\texttt{\textlatin{inter\_3, inter\_4}}), κάτι που θα εξαντλούσε τις διαθέσιμες θύρες του \textlatin{regfile}. Η χρήση ξεχωριστών καταχωρητών απλοποιεί δραστικά τη λογική ελέγχου του \textlatin{datapath} και αποτρέπει δομικές συγκρούσεις (\textlatin{structural hazards}).
\end{itemize}

% 4.4
\newpage
\subsection{Λειτουργία \textlatin{FSM}: Ακολουθιακή Λογική}
Αυτό το τμήμα της \textlatin{FSM} υλοποιείται στο μπλοκ \texttt{\textlatin{always\_ff}} (\textlatin{Block} 7 στο \texttt{\textlatin{nn.v}}). Αυτό είναι το <<αποθηκευτικό>> μέρος του κυκλώματος, που αντιδρά μόνο στις ακμές του ρολογιού ή στο ασύγχρονο \textlatin{reset}.

\begin{itemize}
    \item \textbf{Ασύγχρονο \textlatin{Reset}:} Όταν το \texttt{\textlatin{resetn}} είναι 0 (ενεργό-χαμηλό), το κύκλωμα μηδενίζει αμέσως όλους τους καταχωρητές. Η κατάσταση τίθεται σε \texttt{\textlatin{STATE\_DEACTIVATED}} και όλες οι σημαίες σφάλματος καθαρίζονται (π.χ. \texttt{\textlatin{ovf\_fsm\_stage\_reg <= 3'b111}}).
    \item \textbf{Ακολουθιακή Ενημέρωση:} Σε κάθε θετική ακμή του \texttt{\textlatin{clk}}, συμβαίνουν τρία πράγματα:
        \begin{enumerate}
            \item Η τρέχουσα κατάσταση ενημερώνεται: \texttt{\textlatin{current\_state <= next\_state}}.
            \item Οι μετρητές για τις καταστάσεις πολλαπλών κύκλων προχωρούν. Για το \texttt{\textlatin{STATE\_LOAD}}, ο \texttt{\textlatin{load\_counter}} μετρά από 0 έως 8 (σύνολο 9 κύκλοι). Αυτοί οι 9 κύκλοι απαιτούνται για την αγωγοποιημένη φόρτωση από τη \textlatin{ROM}: 1 κύκλος για την πρώτη αίτηση διευθύνσεων (R0, R1) και 8 επιπλέον κύκλοι για την εγγραφή των 8 ζευγών δεδομένων (R0/R1 έως R14/R15) που έρχονται από τη \textlatin{ROM}. Για το \texttt{\textlatin{STATE\_OUT\_LAYER}}, ο \texttt{\textlatin{output\_step}} μετρά από 0 έως 1 (2 κύκλοι).
            \item Όλα τα ενδιάμεσα δεδομένα (\texttt{\textlatin{\_next}}) αποθηκεύονται στους αντίστοιχους καταχωρητές (\texttt{\textlatin{\_reg}}).
        \end{enumerate}
    \item \textbf{Λογική \textlatin{"Sticky"} Σημαιών:} Οι σημαίες σφάλματος (\texttt{\textlatin{total\_ovf\_reg}}, \texttt{\textlatin{total\_zero\_reg}}) μηδενίζονται \textit{μόνο} κατά την έναρξη μιας νέας επεξεργασίας (δηλαδή, όταν η \textlatin{FSM} φεύγει από το \texttt{\textlatin{STATE\_IDLE}} μέσω του \texttt{\textlatin{enable}}). Σε κάθε άλλη περίπτωση, διατηρούν την τιμή τους (\texttt{\textlatin{total\_ovf\_reg <= total\_ovf\_next}}), γι' αυτό και ονομάζονται \textlatin{sticky}.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{tb_nn_solo_test.png}
    \caption{Έξοδος κονσόλας για επιτυχή εκτέλεση ενός \textlatin{forward pass} (Κανονικό Εύρος).}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth, height=5cm]{EPWave_correct.png}
    \caption{Κυματομορφές \textlatin{EPWave} που δείχνουν την επιτυχή, 5-κύκλων εκτέλεση του \textlatin{pipeline} (Κανονικό Εύρος). Φαίνεται η ομαλή διαδοχή των \textlatin{states} (2-3-4-5-5-6-2) και η ροή των δεδομένων.}
\end{figure}


% 4.5
\subsection{Λειτουργία \textlatin{FSM}: Συνδυαστική Λογική}
Αυτό είναι το <<μυαλό>> της \textlatin{FSM}, που υλοποιείται στο μπλοκ \texttt{\textlatin{always\_comb}} (\textlatin{Block} 8 στο \texttt{\textlatin{nn.v}}). Λειτουργεί ακαριαία και καθορίζει όλες τις ενέργειες του \textlatin{datapath} καθώς και την επόμενη κατάσταση, βασιζόμενο \textit{μόνο} στην \texttt{\textlatin{current\_state}}.

\paragraph{Προεπιλεγμένες Τιμές (\textlatin{Default Values})}
Στην αρχή του μπλοκ, όλες οι έξοδοι και τα σήματα ελέγχου τίθενται σε ασφαλείς, ανενεργές τιμές (π.χ. \texttt{\textlatin{rf\_write\_enable\_s = 1'b0}}, \texttt{\textlatin{next\_state = current\_state}}). Αυτό είναι θεμελιώδες για τη σχεδίαση \textlatin{Moore} και αποτρέπει τη δημιουργία \textlatin{latches}.

\paragraph{Λογική \texttt{\textlatin{case (current\_state)}}}
Η \textlatin{FSM} πλοηγείται στις 7 καταστάσεις της:
\begin{itemize}
    \item \textbf{\texttt{\textlatin{STATE\_DEACTIVATED}}}: Μεταβαίνει στο \texttt{\textlatin{STATE\_LOAD}} μόλις το \textlatin{reset} απενεργοποιηθεί.
    \item \textbf{\texttt{\textlatin{STATE\_LOAD}}}: (9 κύκλοι) Διαχειρίζεται τον \texttt{\textlatin{load\_counter}} για να στείλει τις σωστές διευθύνσεις στη \textlatin{ROM} (π.χ. \texttt{\textlatin{rom\_addr1\_s = (load\_counter * 2) * 4}}) και να ενεργοποιήσει την εγγραφή στο \texttt{\textlatin{regfile}} (π.χ. \texttt{\textlatin{rf\_writeReg1\_s = ((load\_counter - 1) * 2)}}) με τα δεδομένα του προηγούμενου κύκλου. Μετά τον 9ο κύκλο, μεταβαίνει στο \texttt{\textlatin{STATE\_IDLE}}.
    \item \textbf{\texttt{\textlatin{STATE\_IDLE}}}: Αναμένει το σήμα \texttt{\textlatin{enable}}. Όταν \texttt{\textlatin{enable == 1}}, μεταβαίνει στο \texttt{\textlatin{STATE\_PRE\_PROC}}.
    \item \textbf{\texttt{\textlatin{STATE\_PRE\_PROC}}}: (1 κύκλος) Θέτει τα σήματα ελέγχου για παράλληλη εκτέλεση. Συνδέει:
        \begin{itemize}
            \item \texttt{ALU1}: \texttt{\textlatin{input\_1 >>> R[2]}} (όπου \textlatin{R[2]} = \texttt{\textlatin{shift\_bias\_1}})
            \item \texttt{ALU2}: \texttt{\textlatin{input\_2 >>> R[3]}} (όπου \textlatin{R[3]} = \texttt{\textlatin{shift\_bias\_2}})
        \end{itemize}
        Τα αποτελέσματα αποθηκεύονται στα \texttt{\textlatin{inter\_1\_next}} και \texttt{\textlatin{inter\_2\_next}}.
    \item \textbf{\texttt{\textlatin{STATE\_INPUT\_LAYER}}}: (1 κύκλος) Εκτελεί παράλληλα τους δύο νευρώνες. Συνδέει:
        \begin{itemize}
            \item \texttt{MAC1}: \texttt{\textlatin{inter\_1\_reg * R[4] + R[5]}} (όπου \textlatin{R[4]=w1, R[5]=b1})
            \item \texttt{MAC2}: \texttt{\textlatin{inter\_2\_reg * R[6] + R[7]}} (όπου \textlatin{R[6]=w2, R[7]=b2})
        \end{itemize}
        Τα αποτελέσματα αποθηκεύονται στα \texttt{\textlatin{inter\_3\_next}} και \texttt{\textlatin{inter\_4\_next}}.
        m \textbf{\texttt{\textlatin{STATE\_OUT\_LAYER}}}: (2 κύκλοι, σειριακά)
        \begin{itemize}
            \item \textbf{Κύκλος 1 (\texttt{\textlatin{output\_step=0}}):} \texttt{MAC1} $\rightarrow$ \texttt{\textlatin{inter\_3\_reg * R[8] + R[10]}} (\textlatin{w3, b3}). Το αποτέλεσμα σώζεται στο \texttt{\textlatin{temp\_result\_next}}.
            \item \textbf{Κύκλος 2 (\texttt{\textlatin{output\_step=1}}):} \texttt{MAC2} $\rightarrow$ \texttt{\textlatin{inter\_4\_reg * R[9] + temp\_result\_reg}} (\textlatin{w4, temp}). Το αποτέλεσμα σώζεται στο \texttt{\textlatin{inter\_5\_next}}.
        \end{itemize}
        m \textbf{\texttt{\textlatin{STATE\_POST\_PROC}}}: (1 κύκλος) Εκτελεί την τελική ολίσθηση. Συνδέει:
        \begin{itemize}
            \item \texttt{ALU1}: \texttt{\textlatin{inter\_5\_reg << R[11]}} (όπου \textlatin{R[11]} = \texttt{\textlatin{shift\_bias\_3}})
        \end{itemize}
        Το αποτέλεσμα αποθηκεύεται στο \texttt{\textlatin{final\_output\_next}} και η \textlatin{FSM} επιστρέφει στο \texttt{\textlatin{STATE\_IDLE}}.
\end{itemize}


% 4.6
\newpage
\subsection{Διαχείριση Σφαλμάτων (\textlatin{Overflow/Zero})}
Η διαχείριση σφαλμάτων είναι κρίσιμη και υλοποιείται στο τέλος του συνδυαστικού μπλοκ \texttt{\textlatin{always\_comb}}.

\paragraph{Χειρισμός Μηδενισμού (\textlatin{Zero})}
Ο χειρισμός του μηδενισμού είναι <<\textlatin{sticky}>> αλλά δεν διακόπτει τη ροή.
\begin{itemize}
    \item Σε κάθε στάδιο, ελέγχεται αν κάποια ενεργή μονάδα παρήγαγε μηδέν (\texttt{\textlatin{stage\_has\_zero}}).
    \item Αν ναι, η σημαία \texttt{\textlatin{total\_zero\_next}} τίθεται μόνιμα σε 1.
    \item Αν ήταν η \textit{πρώτη} φορά που ανιχνεύτηκε μηδέν (\texttt{\textlatin{total\_zero\_reg == 0}}), η \textlatin{FSM} καταγράφει τον κωδικό του τρέχοντος σταδίου (π.χ. \texttt{3'b100}) στο \texttt{\textlatin{zero\_fsm\_stage\_next}}.
\end{itemize}

\paragraph{Χειρισμός Υπερχείλισης (\textlatin{Overflow})}
Ο χειρισμός της υπερχείλισης υλοποιεί μια λογική παράκαμψης (\textlatin{override}), όπως απαιτείται από τις προδιαγραφές.
\begin{itemize}
    \item Ελέγχεται αν κάποια ενεργή μονάδα παρήγαγε υπερχείλιση (\texttt{\textlatin{stage\_has\_ovf}}).
    \item Αν \texttt{\textlatin{stage\_has\_ovf == 1}}:
    \begin{enumerate}
        \item Η σημαία \texttt{\textlatin{total\_ovf\_next}} τίθεται μόνιμα σε 1.
        \item Αν ήταν η \textit{πρώτη} υπερχείλιση, καταγράφεται ο κωδικός του σταδίου στο \texttt{\textlatin{ovf\_fsm\_stage\_next}}.
        \item \textbf{Παράκαμψη \textlatin{FSM}:} Η \texttt{\textlatin{next\_state}} αναγκάζεται να μεταβεί αμέσως στο \texttt{\textlatin{STATE\_IDLE}}, αγνοώντας όλα τα επόμενα στάδια υπολογισμού.
        \item \textbf{Παράκαμψη Εξόδου:} Η τιμή \texttt{\textlatin{final\_output\_next}} αναγκάζεται να πάρει τη μέγιστη προσημασμένη θετική τιμή, \texttt{\textlatin{32'h7FFFFFFF}}, όπως ορίζουν οι προδιαγραφές.
    \end{enumerate}
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{tb_nn_solo_test_wrong.png}
    \caption{Έξοδος κονσόλας από \textlatin{test case} υπερχείλισης. Δείχνει το \textlatin{[FAIL]} λόγω ασυμφωνίας \textlatin{DUT} (\textlatin{7FFFFFFF}) και \textlatin{Model} (\textlatin{FFFFFFFF}), αλλά επιβεβαιώνει τη σωστή ενεργοποίηση της σημαίας \textlatin{Overflow} (\textlatin{Flag=1}) στο σωστό στάδιο (\textlatin{Stage=100}).}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth, height=5.5cm]{EPWave_wrong.png}
    \caption{Κυματομορφές \textlatin{EPWave} που δείχνουν τη στιγμή της υπερχείλισης. Μόλις το \texttt{\textlatin{current\_state}} φτάνει στο \textlatin{STATE\_INPUT\_LAYER} (4), ανιχνεύεται υπερχείλιση. Στον επόμενο κύκλο, η \textlatin{FSM} αγνοεί τη ροή και επιστρέφει στο \textlatin{IDLE} (2), ενώ το \texttt{\textlatin{total\_ovf}} γίνεται 1 και το \texttt{\textlatin{final\_output}} παίρνει την τιμή \textlatin{7FFFFFFF}.}
\end{figure}



\newpage
% 4.7
\subsection{\textlatin{Testbench} και Αποτελέσματα Προσομοίωσης}
Η επαλήθευση του ολοκληρωμένου συστήματος πραγματοποιήθηκε με το \texttt{\textlatin{tb\_nn.v}}. Αυτό το \textlatin{testbench} ελέγχει το \texttt{\textlatin{nn.v}} \textlatin{(DUT)} συγκρίνοντας την έξοδό του με ένα μαθηματικό μοντέλο αναφοράς, τη συνάρτηση \texttt{\textlatin{nn\_model}}.

\paragraph{Διαχείριση Καθυστέρησης (\textlatin{Latency})}
Το \texttt{\textlatin{nn\_model.v}} είναι συνδυαστικό και δίνει αποτέλεσμα ακαριαία. Το \textlatin{DUT} (\texttt{\textlatin{nn.v}}) είναι ένα ακολουθιακό σύστημα \textlatin{pipeline} 5 κύκλων (1 \textlatin{PRE}, 1 \textlatin{IN}, 2 \textlatin{OUT}, 1 \textlatin{POST}). Το \textlatin{testbench} διαχειρίζεται σωστά αυτή τη διαφορά, περιμένοντας \texttt{\textlatin{FSM\_LATENCY = 5}} κύκλους ρολογιού μετά την ενεργοποίηση (\texttt{\textlatin{enable}}) πριν διαβάσει και συγκρίνει τα αποτελέσματα.

\paragraph{Σχέδιο Δοκιμών (\textlatin{Test Plan})}
Το \textlatin{testbench} εκτελεί 100 επαναλήψεις (\texttt{\textlatin{NUM\_REPETITIONS}}). Κάθε επανάληψη περιλαμβάνει τρεις διαδοχικές δοκιμές με τυχαίες τιμές:
\begin{enumerate}
    \item \textbf{Κανονικό Εύρος:} [\textlatin{-4096}, \textlatin{4095}].
    \item \textbf{Θετική Υπερχείλιση:} [\textlatin{MAX\_POS\_HALF}, \textlatin{MAX\_POS}].
    \item \textbf{Αρνητική Υπερχείλιση:} [\textlatin{MAX\_NEG}, \textlatin{MAX\_NEG\_HALF}].
\end{enumerate}
Στο τέλος, αναφέρει το συνολικό σκορ (π.χ. \textlatin{300 / 300 tests passed}).

\paragraph{Ανάλυση Αποτελεσμάτων (Αναμενόμενη Αποτυχία)}
Όπως φαίνεται στις παρακάτω εικόνες εξόδου του \textlatin{testbench}, η εκτέλεση αναφέρει \texttt{\textlatin{100 / 300 tests passed}}. Συγκεκριμένα, και τα 100 τεστ του <<\textlatin{Normal Range}>> περνούν (\textlatin{PASS}), αλλά και τα 200 τεστ υπερχείλισης \textlatin{(<<Positive/Negative Overflow>>)} αποτυγχάνουν (\textlatin{FAIL}).

Αυτή η αποτυχία είναι \textbf{αναμενόμενη} και οφείλεται σε ασυμφωνία μεταξύ των γραπτών προδιαγραφών και του παρεχόμενου μοντέλου αναφοράς:
\begin{itemize}
    \item \textbf{Οι Προδιαγραφές (\texttt{\textlatin{project\_instructions.pdf}})} ορίζουν ρητά ότι σε περίπτωση υπερχείλισης, η έξοδος του \textlatin{DUT} πρέπει να είναι "ο μέγιστος δυνατός θετικός αριθμός" (\texttt{\textlatin{32'h7FFFFFFF}}).
    \item \textbf{Η Υλοποίησή μου (\texttt{\textlatin{nn.v}})} ακολουθεί πιστά αυτή την οδηγία και παράγει \texttt{\textlatin{32'h7FFFFFFF}} όταν \texttt{\textlatin{stage\_has\_ovf == 1}}.
    \item \textbf{Το Μοντέλο Αναφοράς (\texttt{\textlatin{nn\_model}})} που δόθηκε, ωστόσο, επιστρέφει την τιμή \texttt{\textlatin{32'hFFFFFFFF}} (δηλαδή -1) σε περίπτωση υπερχείλισης.
\end{itemize}
Κατά συνέπεια, το \textlatin{testbench} συγκρίνει την έξοδο του \textlatin{DUT} (\texttt{\textlatin{32'h7FFFFFFF}}) με την έξοδο του μοντέλου (\texttt{\textlatin{32'hFFFFFFFF}}) και αναφέρει σφάλμα (\textlatin{FAIL}). Παρόλα αυτά, οι κυματομορφές που εξετάστηκαν (βλ. προηγούμενη ενότητα) και οι σημαίες εξόδου (\texttt{\textlatin{total\_ovf=1}}) επιβεβαιώνουν ότι η λογική ανίχνευσης υπερχείλισης και η παράκαμψη της \textlatin{FSM} στο \texttt{\textlatin{STATE\_IDLE}} λειτουργούν απολύτως σωστά, ακριβώς όπως ορίστηκε στις γραπτές προδιαγραφές. Είτε εγώ δεν κατανόησα σωστά το <<μέγιστο δυνατό θετικό αριθμό>> που αναφέρετε στη σελίδα 10 του .\textlatin{pdf}, είτε το αρχείο αυτό εξαρχής μου δίνει τα περιθώρια παρανόησης. Ο κώδικας παραμένει \textbf{ορθός }στη λειτουργικότητά του.

\begin{figure}[h!]
    \centering
    % Row 1
    \includegraphics[width=0.49\textwidth]{tb_nn_1.png}
    \hfill
    \includegraphics[width=0.49\textwidth]{tb_nn_2.png}
    
    \vspace{5mm} % Add some vertical space
    
    % Row 2
    \includegraphics[width=0.49\textwidth]{tb_nn_3.png}
    \hfill
    \includegraphics[width=0.49\textwidth]{tb_nn_4.png}
    
    \vspace{5mm} % Add some vertical space
    
    % Row 3
    \includegraphics[width=0.9\textwidth]{tb_nn_RESULTS.png}
    
    \caption{Έξοδος κονσόλας από το πλήρες \textlatin{testbench} (\texttt{\textlatin{tb\_nn.v}}). Οι άνω εικόνες δείχνουν την πρόοδο των 100 επαναλήψεων. Η κάτω εικόνα δείχνει το τελικό αποτέλεσμα \textlatin{(100/300 PASS)}.}
\end{figure}


% 4.8
\subsection{Συμπέρασμα Άσκησης 4}
Η Άσκηση 4 ολοκληρώθηκε με επιτυχία, συνδυάζοντας όλα τα \textlatin{modules} των προηγούμενων ασκήσεων σε ένα λειτουργικό σύστημα επιταχυντή \textlatin{AI}. Η σχεδίαση βασίστηκε σε μια στιβαρή \textlatin{Moore FSM} 7 καταστάσεων που ελέγχει ένα παράλληλο \textlatin{datapath} (2x \textlatin{ALU}, 2x \textlatin{MAC}). Η μονάδα διαχειρίζεται σωστά τη φόρτωση των βαρών από τη \textlatin{ROM} στο \texttt{\textlatin{regfile}}, την εκτέλεση του \textlatin{pipeline} υπολογισμών 5 κύκλων, και τον κρίσιμο μηχανισμό παράκαμψης σε περίπτωση υπερχείλισης. Η επαλήθευση μέσω \textlatin{testbench} επιβεβαίωσε την ορθότητα της σχεδίασης σε σχέση με τις γραπτές προδιαγραφές, με τις αναμενόμενες αποτυχίες των \textlatin{tests} υπερχείλισης να οφείλονται αποκλειστικά στην ασυμφωνία του reference model με τις προδιαγραφές.


\end{document}
