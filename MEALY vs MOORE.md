1. Ορισμός Mealy vs. Moore

    Σε μια Moore FSM, οι έξοδοι (τα σήματα ελέγχου) εξαρτώνται αποκλειστικά και μόνο από την τρέχουσα κατάσταση.

    Σε μια Mealy FSM, οι έξοδοι εξαρτώνται και από την τρέχουσα κατάσταση και από τις τρέχουσες εξωτερικές εισόδους (όπως το enable).

2. Γιατί Moore FSM;

Στον σχεδιασμό μας, οι ενέργειες που πρέπει να γίνουν εξαρτώνται μόνο από το ποιο στάδιο εκτελούμε, όχι από το τι κάνει ο χρήστης εκείνη τη στιγμή.

    Στο STATE_PRE_PROC: Θέλουμε πάντα οι δύο alu να κάνουν Αριθμητική Ολίσθηση Δεξιά. Αυτή η απόφαση δεν εξαρτάται από καμία εξωτερική είσοδο.

    Στο STATE_INPUT_LAYER: Θέλουμε πάντα οι δύο mac_unit να εκτελούν τις παράλληλες πράξεις τους.

    Στο STATE_LOAD: Θέλουμε πάντα να γράφουμε στο regfile και να διαβάζουμε από τη rom.

Η μόνη εξωτερική είσοδος που μας ενδιαφέρει (εκτός του resetn) είναι το enable. Ωστόσο, το enable δεν αλλάζει τι κάνουμε, αλλά το πότε το κάνουμε. Επηρεάζει μόνο τη μετάβαση από το STATE_IDLE στο STATE_PRE_PROC, όχι τις ίδιες τις εξόδους.

3. Το Πλεονέκτημα Ασφάλειας (Αποφυγή Glitch)

Αυτός είναι ο πιο σημαντικός λόγος. Επειδή οι έξοδοι μιας Moore FSM αλλάζουν μόνο στην ακμή του ρολογιού (όταν αλλάζει η κατάσταση), τα σήματα ελέγχου μας (π.χ. regfile_write_enable, alu_op_select κ.λπ.) είναι σταθερά και εγγυημένα για ολόκληρο τον κύκλο ρολογιού.

Αν χρησιμοποιούσαμε Mealy, μια τυχαία, στιγμιαία αλλαγή (ένα "glitch") στην είσοδο enable ενώ βρισκόμασταν σε άλλη κατάσταση, θα μπορούσε θεωρητικά να προκαλέσει ένα στιγμιαίο "glitch" και στις εξόδους ελέγχου. Αυτό θα μπορούσε να οδηγήσει σε καταστροφικά σφάλματα, όπως μια ακούσια εγγραφή στο regfile σε λάθος χρόνο.

Συμπέρασμα: Επιλέγουμε Moore FSM επειδή οδηγεί σε έναν πιο καθαρό, απλό και—το κυριότερο—πιο ασφαλή σχεδιασμό, όπου οι έξοδοι ελέγχου είναι συγχρονισμένες και σταθερές, όπως απαιτείται για τον έλεγχο ευαίσθητων μονάδων όπως το regfile και η alu.